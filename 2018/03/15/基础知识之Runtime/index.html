<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="iOS," />










<meta name="description" content="Runtimewhat is RuntimeObjective-C Runtime是一个将C语言转化为面向对象语言的扩展。C++和Objective-C都是在C的基础上加入面向对象的特性扩充而成的程序设计语言，但是C++是基于静态类型而Objective-C是基于动态运行时类型的。用C++编写的程序通过编译器直接把函数地址硬编码进入可执行文件，而Objective-C无法通过编译器直接把函数地址硬">
<meta name="keywords" content="iOS">
<meta property="og:type" content="article">
<meta property="og:title" content="基础知识之Runtime">
<meta property="og:url" content="http://yoursite.com/2018/03/15/基础知识之Runtime/index.html">
<meta property="og:site_name" content="Road To Coder">
<meta property="og:description" content="Runtimewhat is RuntimeObjective-C Runtime是一个将C语言转化为面向对象语言的扩展。C++和Objective-C都是在C的基础上加入面向对象的特性扩充而成的程序设计语言，但是C++是基于静态类型而Objective-C是基于动态运行时类型的。用C++编写的程序通过编译器直接把函数地址硬编码进入可执行文件，而Objective-C无法通过编译器直接把函数地址硬">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-03-15T08:40:28.620Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="基础知识之Runtime">
<meta name="twitter:description" content="Runtimewhat is RuntimeObjective-C Runtime是一个将C语言转化为面向对象语言的扩展。C++和Objective-C都是在C的基础上加入面向对象的特性扩充而成的程序设计语言，但是C++是基于静态类型而Objective-C是基于动态运行时类型的。用C++编写的程序通过编译器直接把函数地址硬编码进入可执行文件，而Objective-C无法通过编译器直接把函数地址硬">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/03/15/基础知识之Runtime/"/>





  <title>基础知识之Runtime | Road To Coder</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Road To Coder</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/15/基础知识之Runtime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bokice">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Road To Coder">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">基础知识之Runtime</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-15T16:39:50+08:00">
                2018-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h1><h1 id="what-is-Runtime"><a href="#what-is-Runtime" class="headerlink" title="what is Runtime"></a>what is Runtime</h1><p>Objective-C Runtime是一个将C语言转化为面向对象语言的扩展。C++和Objective-C都是在C的基础上加入面向对象的特性扩充而成的程序设计语言，但是C++是基于静态类型而Objective-C是基于动态运行时类型的。用C++编写的程序通过编译器直接把函数地址硬编码进入可执行文件，而Objective-C无法通过编译器直接把函数地址硬编码进入可执行文件，而是在函数运行的时候，利用Rumtime根据条件判断做出决定。函数标识与函数过程的真正内容之间的关联可以动态修改。</p>
<h2 id="Objective-C相关基础"><a href="#Objective-C相关基础" class="headerlink" title="Objective-C相关基础"></a>Objective-C相关基础</h2><h3 id="id-amp-Class"><a href="#id-amp-Class" class="headerlink" title="id &amp; Class"></a>id &amp; Class</h3><p>objc.h文件中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !OBJC_TYPES_DEFINED</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span><span class="comment">//Class是指向objc_class结构体的指针</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span>&#123;</span></span><br><span class="line">  Class isa OBJC_ISA_AVAILABILITY;<span class="comment">//isa是Class，即是指向objc_class结构体的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span><span class="comment">//id是指向objc_object结构体的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>runtime.h文件中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> *<span class="title">Class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span>&#123;</span></span><br><span class="line">  Class isa					OBJC_ISA_AVAILABILITY;<span class="comment">//metaClass</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> !__OBJC2__</span></span><br><span class="line">  Class supe_class			OBJC2_UNAVAILABLE;<span class="comment">//父类</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name			OBJC2_UNAVAILABLE;<span class="comment">//类名</span></span><br><span class="line">  <span class="keyword">long</span> verson			OBJC2_UNAVAILABLE;<span class="comment">//类的版本信息，默认为0，可以通过runtime函数class_setVersion或者class_getVersion进行修改、读取</span></span><br><span class="line">  <span class="keyword">long</span> info			OBJC2_UNAVAILABLE;<span class="comment">//类信息，供运行时使用的一些位标识，如CLS_CLASS表示该类为普通class，其中包含示例方法和变量;CLS_META表示该类为metaClass，其中包含类方法</span></span><br><span class="line">  <span class="keyword">long</span> instance_size			OBJC2_UNAVAILABLE;<span class="comment">//该类的示例变量大小，其中包括从父类继承下来的实例变量</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">objc_ivar_list</span> *<span class="title">ivars</span>			<span class="title">OBJC2_UNAVAILABLE</span>;</span><span class="comment">//该类的成员变量地址列表</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> **<span class="title">methodLists</span>			<span class="title">OBJC2_UNAVAILABLE</span>;</span><span class="comment">//方法地址列表，与info的标志位有关，如果是CLS_CLASS，则存储实例方法，如果是CLS_META，则存储类方法</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">cache</span>			<span class="title">OBJC2_UNAVAILABLE</span>;</span><span class="comment">//缓存最近使用的方法地址，用于提升效率</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>			<span class="title">OBJC2_UNAVAILABLE</span>;</span><span class="comment">//存储该类声明遵守的协议的列表</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类和对象的区别就是类比对象多了很多特征成员。类也可以当做一个objc_object来对待，即类和对象都是对象，分别称作类对象(class object)和实例对象(instance object)</p>
<ul>
<li><p>isa</p>
<p>objc_object(实例对象)中isa指针指向的类结构称为class(也就是该对象所属的类)，其中存放着普通成员变量与动态方法(“-“开头的方法)，而此处isa指针指向的类结构称为metaclass，其中存放着static类型的成员变量与static类型的方法(“+”开头的方法)。</p>
</li>
</ul>
<ul>
<li><p>super_class</p>
<p>指向该类的父类的指针，如果该类是根类(NSObject\NSProxy)，则super_class为nil</p>
</li>
</ul>
<p><strong>所有的metaclass中的isa指针都是指向根metaclass的，而根metaclass则指向自身。metaclass通过继承根类产生，与根class结构体成员一致，不同的是根metaclass的isa指针指向自己</strong></p>
<h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p>SEL是selector在Objective-C中的表示类型，selector可以理解为区别方法的ID</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> *<span class="title">SEL</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> *name; OBJC2_UNAVAILABLE;<span class="comment">//名称</span></span><br><span class="line">  <span class="keyword">char</span> *types; OBJC2_UNAVAILABLE;<span class="comment">//类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p>objc.h中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">id</span> <span class="params">(*IMP)</span><span class="params">(id, SEL, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>IMP是implementation的缩写，是由编译器生成的一个函数指针，当发起一个消息后，该函数指针决定了最终指向哪段代码。</p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> *<span class="title">Method</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span>&#123;</span></span><br><span class="line">  SEL method_name OBJC_UNAVAILABLE;<span class="comment">//方法名</span></span><br><span class="line">  <span class="keyword">char</span> *method_types OBJC_UNAVAILABLE;<span class="comment">//方法类型，存储了方法的参数类型和返回值类型</span></span><br><span class="line">  IMP method_imp OBJC_UNAVAILABLE;<span class="comment">//方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h3><p>类中示例变量的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_ivar *Ivar;</span><br><span class="line">struct objc_ivar&#123;</span><br><span class="line">  char *ivar_name OBJC2_UNAVAILABLE;//变量名</span><br><span class="line">  char *ivar_type OBJC2_UNAVAILABLE;//变量类型</span><br><span class="line">  int ivar_offset OBJC2_UNAVAILABLE;//基地址偏移字节</span><br><span class="line">  #ifdef __LP64__</span><br><span class="line">  int space OBJC2_UNAVAILABLE;//占用空间</span><br><span class="line">  #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="objc-property-t"><a href="#objc-property-t" class="headerlink" title="objc_property_t"></a>objc_property_t</h3><p>objc_property_t 是属性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_property</span> *<span class="title">objc_property_t</span>;</span></span><br></pre></td></tr></table></figure>
<p>objc_property是内置的类型，与之关联的是objc_property_attribute_t，是对属性的名称、编码类型、原子类型等的描述</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *value;</span><br><span class="line">&#125; <span class="keyword">objc_property_attribute_t</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span> *<span class="title">Cache</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_cache</span>&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> mask OBJC2_UNAVAILABLE;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> occupied OBJC2_UNAVAILABLE;</span><br><span class="line">  Method buckets[<span class="number">1</span>] OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mask:指定分配cache buckets的总数</p>
<p>occupied:实际占用cache buckets的总数</p>
<p>buckets:指定Method数据结构指针的数组，包含不超过mask+1个元素。</p>
<p>objc_msgSend每次调用一次方法后，就会把该方法缓存到cache列表中，下次直接优先从cache列表中寻找，若未找到再到methodLists中查找方法。</p>
<h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><p>动态为已存在的类添加方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_category</span> *<span class="title">Category</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_category</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> *category_name;<span class="comment">//类别名</span></span><br><span class="line">  <span class="keyword">char</span> *class_name;<span class="comment">//类名</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> *<span class="title">instance_methods</span>;</span><span class="comment">//实例方法名</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">objc_method_list</span> *<span class="title">class_method</span>;</span><span class="comment">//类方法名</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">objc_protocol_list</span> *<span class="title">protocols</span>;</span><span class="comment">//协议列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Objective-C的消息传递"><a href="#Objective-C的消息传递" class="headerlink" title="Objective-C的消息传递"></a>Objective-C的消息传递</h2><h3 id="基本消息传递"><a href="#基本消息传递" class="headerlink" title="基本消息传递"></a>基本消息传递</h3><p>Runtime会根据类型自动转换成以下函数之一</p>
<ul>
<li>objc_msgSend:普通消息</li>
<li>objc_msgSend_stret:消息中有数据结构作为返回值</li>
<li>objc_msgSendSuper:将消息发送给父类</li>
<li>objc_msgSendSuper_stret</li>
</ul>
<p>objc_msgSend函数的调用过程</p>
<ol>
<li>检测selector是否要忽略</li>
<li>检测target是否nil对象</li>
<li>调用实例方法时，先在自身isa指向的类的methodLists中查找该方法，如果找不到则通过class的super_class指针找到父类的类对象结构体，在父类的methodLists中查找该方法，直到根class;</li>
<li>若调用的是类方法，则在其metaclass中执行步骤3.</li>
<li>动态方法解析</li>
</ol>
<h3 id="消息动态解析"><a href="#消息动态解析" class="headerlink" title="消息动态解析"></a>消息动态解析</h3><ol>
<li><p>resolveInstanceMethod</p>
<p>决定是否动态添加方法，是则通过class_addMethod动态添加方法，否则继续</p>
</li>
<li><p>forwardingTargetForSelector</p>
<p>指定备选对象(不能是self)响应这个selector，如果返回nil，则继续</p>
</li>
<li><p>methodSignatureForSelector</p>
<p>通过该方法进行签名，如果返回nil，则消息无法处理，如果返回methodSignature，则继续</p>
</li>
<li><p>forwardInvocation</p>
<p>通过anInvocation对象做很多处理，如修改实现方法，修改响应对象等，如果方法调用成功则结束，如果失败则进入doesNotRecognizeSelector方法</p>
</li>
</ol>
<h1 id="———————分割线——————————"><a href="#———————分割线——————————" class="headerlink" title="———————分割线——————————"></a>———————分割线——————————</h1><h2 id="成员变量与属性"><a href="#成员变量与属性" class="headerlink" title="成员变量与属性"></a>成员变量与属性</h2><h3 id="类型编码"><a href="#类型编码" class="headerlink" title="类型编码"></a>类型编码</h3><p>   编译器将每个方法的返回值和参数类型编码为一个字符串，并将其与方法的selector关联到一起，这种编码防范在其他情况下也是非常有用的，可以使用@encode编译器指令来获取，当给定一个类型时，@encode返回该类型的字符串编码。这些类型可以是注入int、指针这样的基本类型，也可以是结构体、类等类型。任何可以作为sizeof()操作参数的类型都可以用于@encode()。</p>
<p>   类型编码大多与用于存档和分发的编码类型是相同的，但有一些不能在存档时使用。</p>
<p>   另外还有一些编码类型，@encode虽然不会直接返回他们，但他们可以作为协议中声明的方法的类型限定符。</p>
<p>   对于属性而言，还有一些特殊的类型编码，以表明属性是只读、拷贝、retain等。</p>
<h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><p>   针对分类不能添加新的成员变量，Objective-C提供的解决方案，即Associated Object。</p>
<p>   可以将关联对象想象成一个Objctive-C对象，这个对象通过给定的key连接到类的一个实例上，由于使用的是C接口，所以key是一个void指针。并通过指定一个内存管理策略，告诉Runtime如何管理这个对象的内存，内存管理策略可以由以下值指定:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OBJC_ASSOCIATION_ASSIGN</span><br><span class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><br><span class="line">OBJC_ASSOCIATION_COPY_NONATOMIC</span><br><span class="line">OBJC_ASSOCIATION_RETAIN</span><br><span class="line">OBJC_ASSOCIATION_COPY</span><br></pre></td></tr></table></figure>
<p>当宿主对象被释放时，会根据指定的内存管理策略来处理关联对象，如果指定的策略时assign，当宿主释放时，关联对象不会被释放，如果指定的是retain或copy，则宿主释放时，关联对象会被释放。</p>
<p>将一个对象连接到其他对象所需要做的就是以下两行代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static char myKey;</span><br><span class="line">objc_setAssociatedObject(self, &amp;myKey, anObject, OBJC_ASSOCIATION_RETAIN);</span><br></pre></td></tr></table></figure>
<p>当使用同一个key来关联另一个对象时，会自动释放之前关联的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id anObject = objc_getAssociatedObject(self, &amp;myKey);</span><br></pre></td></tr></table></figure>
<p>可以使用objc_removeAssociatedObjects函数来移除一个关联对象，或者使用objc_setAssociatedObject函数将key指定的关联对象设置为nil。</p>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><h4 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//获取成员变量名</span><br><span class="line">const char * ivar_getName(Ivar v);</span><br><span class="line">//获取成员变量类型编码</span><br><span class="line">const char * ivar_getTypeEncoding(Ivar v);</span><br><span class="line">//获取成员变量的偏移量，对于类型id或其他对象类型的实例变量，可以调用object_getIvar和object_setIvar来直接访问成员变量，而不是偏移量</span><br><span class="line">ptrdiff_t ivar_getOffset(Ivar v);</span><br></pre></td></tr></table></figure>
<h4 id="关联对象-1"><a href="#关联对象-1" class="headerlink" title="关联对象"></a>关联对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);</span><br><span class="line">void objc_getAssociatedObject(id object, const void *key);</span><br><span class="line">void objc_removeAssociatedObjects(id object);</span><br></pre></td></tr></table></figure>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//获取属性名</span><br><span class="line">const char * property_getName(objc_property_t property);</span><br><span class="line">//获取属性特性描述字符串</span><br><span class="line">const char * property_getAttributes(objc_property_t property);</span><br><span class="line">//获取属性中指定的特定</span><br><span class="line">char * property_copyAttributeValue(objc_property_t property,const char *attributeName);</span><br><span class="line">//获取属性的特性列表，返回的char*在使用完后要调用free()释放掉</span><br><span class="line">objc_property_attribute_t * property_copyAttributeList(objc_property_t property, unsigned int *outCount);</span><br></pre></td></tr></table></figure>
<h2 id="方法与消息"><a href="#方法与消息" class="headerlink" title="方法与消息"></a>方法与消息</h2><p>方法的selector用于表示运行时方法的名字，Objective-C在编译时会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(int类型的地址)，这个标识就是SEL。</p>
<p>任何两个类，只要方法名相同，那么方法的SEL就是一样的。所以在Objective-C同一个类中，不能存在两个同名方法，参数类型不同也不行。从而导致了Objective-C在处理相同方法名且参数个数相同但类型不同的方法方面的能力很差。</p>
<p>不同的类可以拥有相同的selector，因为不同类的实例对象执行相同的selector时，会在格子的方法列表中取根据selector去寻找自己对应的IMP。</p>
<p>在方法集合中查找方法时通过查找相应的SEL即可，而SEL实际上是根据方法名hash化了的字符串，而对于字符串的比较仅仅比较其地址即可。然而数量增多会导致性能下降，而SEL仅仅使用函数名可以使总量减少。</p>
<p>可以在运行时添加新的selector，也可以在运行时获取已存在的selector，可以通过以下三种方法来获取SEL</p>
<ol>
<li>sel_registerName函数</li>
<li>Objective-C编译器提供的@selector()</li>
<li>NSSelectorFromString()方法</li>
</ol>
<h3 id="IMP-1"><a href="#IMP-1" class="headerlink" title="IMP"></a>IMP</h3><p>实际上是一个函数指针，指向方法实现的首地址。</p>
<p>这个函数是用当前CPU架构实现的标准的C调用约定。第一个参数指向self的指针(如果是实例方法，则指向类实例的内存地址，如果是类方法，则指向元类内存地址)，第二个参数是方法选择器(selector)，接下来是方法的实际参数列表。</p>
<p>SEL是为了查找方法的最终实现IMP。每个方法的SEL唯一，因此可以通过SEL方便快速准确地获取其对应的IMP，即获得了执行这个方法代码的入口点。</p>
<p>通过取得IMP，可以跳过Runtime的消息传递机制，直接执行IMP指向的函数实现，省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些。</p>
<h3 id="方法相关操作函数"><a href="#方法相关操作函数" class="headerlink" title="方法相关操作函数"></a>方法相关操作函数</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//调用指定方法的实现</span><br><span class="line">id method_invoke(id receiver, Method m, ...);</span><br><span class="line">//调用返回一个数据结构的方法的实现</span><br><span class="line">void method_invoke_stret(id receiver, Method m, ...);</span><br><span class="line">//获取方法名</span><br><span class="line">SEL method_getName(Method m);</span><br><span class="line">//返回方法的实现</span><br><span class="line">IMP method_getImplementation(Method m);</span><br><span class="line">//获取描述方法参数和返回值类型的字符串</span><br><span class="line">const char * method_getTypeEncoding(Method m);</span><br><span class="line">//获取方法的返回值类型的字符串</span><br><span class="line">char * method_copyReturnType(Method m);</span><br><span class="line">//获取方法的指定位置的类型字符串</span><br><span class="line">char * method_copyArgumentType(Method m, unsigned int index);</span><br><span class="line">//通过引用返回方法的返回值类型字符串</span><br><span class="line">void method_getReturnType(Method m, char *dst, size_t dst_len);</span><br><span class="line">//返回方法的参数的个数</span><br><span class="line">unsigned int method_getNumberOfArguments(Method m);</span><br><span class="line">//通过引用返回方法指定位置参数的类型字符串</span><br><span class="line">void Method_getArgumentType(Method m, Unsigned int index, char *dst, size_t dst_len);</span><br><span class="line">//返回指定方法的方法描述结构体</span><br><span class="line">struct objc_method_description * method_getDescription(Method m);</span><br><span class="line">//设置方法的实现，返回值是old实现</span><br><span class="line">IMP method_setImplementation(Method m, IMP imp);</span><br><span class="line">//交换两个方法的实现</span><br><span class="line">void method_exchangeImplementations(Method m1, Method m2);</span><br></pre></td></tr></table></figure>
<h4 id="方法选择器"><a href="#方法选择器" class="headerlink" title="方法选择器"></a>方法选择器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//返回给定选择器指定的方法的名称</span><br><span class="line">const char * sel_getName(SEL sel);</span><br><span class="line">//注册一个方法，将方法名映射到一个选择器，并返回这个选择器。在将一个方法添加到类定义时，必须在objective-C Runtime系统中注册方法名以获取方法的选择器</span><br><span class="line">SEL sel_registerName(const char *str);</span><br><span class="line">//注册一个方法</span><br><span class="line">SEL sel_getUid(const char *str);</span><br><span class="line">//比较两个选择器</span><br><span class="line">BOOL sel_isEqual(SEL lhs, SEL rhs);</span><br></pre></td></tr></table></figure>
<h3 id="方法调用流程"><a href="#方法调用流程" class="headerlink" title="方法调用流程"></a>方法调用流程</h3><h4 id="隐藏参数"><a href="#隐藏参数" class="headerlink" title="隐藏参数"></a>隐藏参数</h4><p>objc_msgSend有两个隐藏参数</p>
<ol>
<li>消息接收对象</li>
<li>方法的selector</li>
</ol>
<p>在定义方法的源代码中没有声明，是在编译期间被插入实现代码的。</p>
<p>虽然这两个参数没有显式声明，但是在代码中仍然可以引用。可以通过self来引用接收者对象，用_cmd来引用选择器。</p>
<h4 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h4><p>Runtime中方法的动态绑定让我们写代码时更具灵活性，例如将消息转发给我们想要的对象，或者随意交换一个方法的实现。然而方法实现的查找带来性能的损耗，尽管方法的缓存能在一定程度上降低这种损耗。</p>
<p>如果要避开动态绑定方式，可以获取方法实现的地址，然后像调用函数一样来直接调用它，特别是当需要在一个循环内频繁地调用一个特定的方法时，通过这种方式可以提高程序的性能。</p>
<p>NSObjecti类提供了methodForSelector方法让我们可以获取方法的指针，然后通过这个指针来调用实现代码，使用时需要将methodForSelector返回的指针转换为合适的函数类型，函数参数和返回值都需要匹配。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void (*setter)(id, SEL, BOOL);</span><br><span class="line">int i;</span><br><span class="line">setter = (void (*)(id,SEL,BOOL))[target methodForSelector:@selector(setFilled:)];</span><br><span class="line">for(i=0;i&lt;1000;i++)&#123;</span><br><span class="line">  setter(targetList[i],@selector(setFilled:),YES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的前两个参数必须是id和SEL</p>
<p>这种方式只适用于在类似于for循环这种情况下频繁调用同一方法来提高性能的情况。</p>
<p>methodForSelector:是由Cocoa运行时提供的，不是Objective-C语言的特性</p>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>默认情况下，如果以[object message]的方式调用方法，如果object无法响应message消息时，编译器会报错。如果以perform…的形式来调用，则需要等到运行时才能确定object是否能结束message。</p>
<p>当一个对象无法接受某一消息时，会启动消息转发机制。</p>
<p>消息转发机制基本上分三个步骤:</p>
<ol>
<li>动态方法解析</li>
<li>备用接收者</li>
<li>完整转发</li>
</ol>
<h4 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h4><p>对象在接收到未知消息时，首先会调用所属类的类方法+resolveInstanceMethod或者 +resolveClassMethod。在这个方法中将有机会为该未知消息新增一个处理方法，不过使用该方法的前提是提前实现该方法。这需要在运行时通过class_addMethod函数动态添加到类里面。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void functionForMethod1(id self, SEL _cmd)&#123;</span><br><span class="line">  NSLog(@&quot;%@,%p&quot;, self, _cmd);</span><br><span class="line">&#125;</span><br><span class="line">+(BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line">  NSString *selectorString = NSStringFromSelector(sel);</span><br><span class="line">  if([selectorString isEqualToString:@&quot;method1&quot;])&#123;</span><br><span class="line">    class_addMethod(self.class,@selector(method1),(IMP)functionForMethod1,&quot;@:&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方案更多是为了实现@dynamic属性</p>
<h4 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h4><p>如果上一步无法处理消息，Runtime会继续调用以下方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(id)forwardingTargetForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure>
<p>如果一个对象实现了这个方法，并返回一个非nil的结果，则这个对象会作为消息的新接收者，且消息会被分发到这个对象。指定self将导致无线循环。</p>
<p>使用这个方法通常是在对象内部，可能还有一些列其他对象能处理该消息，便可以这些对象来处理消息并返回。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">@interface SUTRuntimeMethodHelper : NSObject</span><br><span class="line"></span><br><span class="line">-(void)method2;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SUTRuntimeMethodHelper</span><br><span class="line"></span><br><span class="line">-(void) method2 &#123;</span><br><span class="line">  NSLog(@&quot;%@,%p&quot;,self,_cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">#pragma mark -</span><br><span class="line">  </span><br><span class="line">@interface SUTRuntimeMethod()&#123;</span><br><span class="line"> SUTRuntimeMethodHelper *_helper;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation SUTRuntimeMethod</span><br><span class="line"></span><br><span class="line">+(instancetype)object&#123;</span><br><span class="line">  return [[self alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">-(instancetype)init&#123;</span><br><span class="line">  self=[super init];</span><br><span class="line">  if(self!=nil)&#123;</span><br><span class="line">    _helper=[[SUTRuntimeMethodHelper alloc] init];</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br><span class="line">-(void)test&#123;</span><br><span class="line">  [self performSelector:@selector(method2)];</span><br><span class="line">&#125;</span><br><span class="line">-(void)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">  NSLog(@&quot;forwardingTargetForSelector&quot;);</span><br><span class="line">  NSString *selectorString = NSStringFroSelector(aSelector);</span><br><span class="line">  if([selectorString isEqualToString:@&quot;method2&quot;])&#123;</span><br><span class="line">    return _helper;</span><br><span class="line">  &#125;</span><br><span class="line">  return [super forwardingTargetForSelector:aSelecotr];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>适合于指向将消息转发到另一个能处理该消息的对象上，但这一步无法对消息进行处理，如操作消息的参数和返回值。</p>
<h4 id="完整消息转发"><a href="#完整消息转发" class="headerlink" title="完整消息转发"></a>完整消息转发</h4><p>如果上一步无法处理未知消息，唯一能做的就是启用完整的消息转发机制，此时调用一下方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)forwardInvocation:(NSInvocation *)anInvocation</span><br></pre></td></tr></table></figure>
<p>运行时系统会在这一步给消息接收者最后一次机会将消息转发给其他对象。对象会创建一个表示消息的NSInvocation对象，把尚未处理的消息相关的消息有改观的全部细节都封装在anInvocation中，包括selector，目标target和参数，我们可以在forwardInvocation方法中选择将消息转发给其他对象。</p>
<p>forwardInvocation方法的实现有两个任务:</p>
<ol>
<li>定位可以相应封装在anInvocation中的消息的独享，这个对象不需要能处理所有未知消息</li>
<li>使用anInvocation作为参数，将消息发送到选中的对象。anInvocation将会保留调用结果，运行时系统会提取这一结果并将其发送到消息的原始发送者。</li>
</ol>
<p>在这个方法中可以实现一些更复杂的功能，可以对消息的内容进行修改。</p>
<p>此外，必须重写以下方法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure>
<p>消息转发机制使用从这个方法中获取的信息来创建NSInvocation对象，因此需要重写这个方法为给定的selector提供一个合适的方法签名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">  NSMethodSignature *signature=[super methodSignatureForSelector:aSelector];</span><br><span class="line">  if(!signature)&#123;</span><br><span class="line">    if([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector])&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;signature=[SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">  &#125;</span><br><span class="line">  return signature;</span><br><span class="line">&#125;</span><br><span class="line">-(void)forwardInvocation:(NSInvocation *)anInvocation&#123;</span><br><span class="line">  if([SUTRuntimeMethodHelper instancesResponedToSelector:anInvocation.selector])&#123;</span><br><span class="line">    [anInvocation invokeWithTarget:_helper];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NSObject的forwardingInvocation方法实现知识简单调用了doesNotRecognizeSelector:方法，不会转发任何消息，所以将导致异常。</p>
<h4 id="消息转发与多重继承"><a href="#消息转发与多重继承" class="headerlink" title="消息转发与多重继承"></a>消息转发与多重继承</h4><p>消息转发虽然类似于继承，但NSObject的一些方法还是能区分两者，如respondsToSelector:和isKindOfClass:只能用于继承体系而不能用于转发链。</p>
<h2 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h2><p>Method swizzling是改变一个selector的实际实现的技术。通过这一技术，可以在运行时修改类的分发表中selector对应的函数，来修改方法的实现。</p>
<h3 id="swizzling应该总是在-load中执行"><a href="#swizzling应该总是在-load中执行" class="headerlink" title="swizzling应该总是在+load中执行"></a>swizzling应该总是在+load中执行</h3><p>Objective-C运行时会自动调用每个类的两个方法，+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法都是可选的 ，且只有在实现了他们时才会被调用。由于method swizzling会影响到类的全局状态，因此尽量避免在并发处理中出现竞争的情况。+load能保证在类的初始化过程中被加载，并保证这种改变应用级别的行为的一致性。相比之下initialize在其执行时不提供这种保证。</p>
<h3 id="swizzling应该总是在dispatch-once中执行"><a href="#swizzling应该总是在dispatch-once中执行" class="headerlink" title="swizzling应该总是在dispatch_once中执行"></a>swizzling应该总是在dispatch_once中执行</h3><p>确保代码之执行一次</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>总是调用方法的原始实现。</li>
<li>避免冲突</li>
</ol>
<h2 id="协议与分类"><a href="#协议与分类" class="headerlink" title="协议与分类"></a>协议与分类</h2><h3 id="Category-1"><a href="#Category-1" class="headerlink" title="Category"></a>Category</h3><p>见上</p>
<h3 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_object Protocol;</span><br></pre></td></tr></table></figure>
<p>即Protocol其实是一个对象结构体</p>
<h3 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h3><h4 id="category"><a href="#category" class="headerlink" title="category"></a>category</h4><p>可以通过针对objc_class的操作函数来获取分类的信息。</p>
<h4 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a>protocol</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//返回指定协议，如果仅声明了协议而未在任何类中实现该协议，则函数返回nil</span><br><span class="line">Protocol * objc_getProtocol(const char *name);</span><br><span class="line">//获取运行时所知道的所有协议的数组，获取到的数组需要使用free来释放</span><br><span class="line">Protocol ** objc_copyProtocolList(unsigned int *outCount);</span><br><span class="line">//创建新的协议实例，如果同名的协议已存在，则返回nil</span><br><span class="line">Protocol * objc_allocateProtocol(const char *name);</span><br><span class="line">//在运行时中注册新创建的协议，创建一个新的协议后，必须调用该函数以在运行时中注册新的协议，协议注册后便可以使用，但不能再做修改，即无法再调用protocol_addMethodDescription/protocol_addProtocol/protocol_addProperty方法</span><br><span class="line">void objc_registerProtocol(Protocol *proto);</span><br><span class="line">//为协议添加方法</span><br><span class="line">void protocol_addMethodDescription(Protocol *proto, SEL name, const char *type, BOOL isRequiredMethod, BOOL isInstanceMethod);</span><br><span class="line">//添加一个已注册的协议到协议中</span><br><span class="line">void protocol_addProtocol(Protocol *proto, Protocol *addition);</span><br><span class="line">//为协议添加属性</span><br><span class="line">void protocol_addProperty(Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty);</span><br><span class="line">//返回协议名</span><br><span class="line">const char * protocol_getName(Protocol *p);</span><br><span class="line">//测试两个协议是否相等</span><br><span class="line">BOOL protocol_isEqul(Protocol *proto, Protocol *other);</span><br><span class="line">//获取协议中指定条件的方法的方法描述数组</span><br><span class="line">struct objc_method_description * protocol_copyMethodDescriptionList(Protocol *p, BOOL isRequireMethod, BOOL isInstanceMethod, unsigned int *outCount);</span><br><span class="line">//获取协议中指定方法的方法描述</span><br><span class="line">struct objc_method_description protocol_getMethodDescriptiion(Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod);</span><br><span class="line">//获取协议中的属性列表</span><br><span class="line">objc_proprety_t * protocol_copyPropertyList (Protocol *proto,unsigned int *outCount);</span><br><span class="line">//获取协议的指定属性</span><br><span class="line">objc_property_t protocol_getProperty(Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty);</span><br><span class="line">//获取协议采用的协议</span><br><span class="line">Protocol ** protocol_copyProtocolList(Protocol *proto,unsigned int *outCount);</span><br><span class="line">//查看协议是否采用了另一个协议</span><br><span class="line">BOOL protocol_conformsToProtocol(Protocol *proto, Protocol *other);</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>self是类的隐藏参数，super不是类的隐藏参数而是编译器标示符，负责告诉编译器去调用父类的方法，而消息的接收者仍是self。即发送消息时，调用的是objc_msgSendSuper函数。</p>
<p>参考</p>
<p><a href="http://southpeak.github.io/" target="_blank" rel="noopener">http://southpeak.github.io/</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/15/禅与Objective-C编程艺术笔记/" rel="next" title="禅与Objective-C编程艺术笔记">
                <i class="fa fa-chevron-left"></i> 禅与Objective-C编程艺术笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/15/Mach-O文件格式分析/" rel="prev" title="Mach-O文件格式分析">
                Mach-O文件格式分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Bokice</p>
              <p class="site-description motion-element" itemprop="description">记录学习历程，向开源大神看齐</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Runtime"><span class="nav-number">1.</span> <span class="nav-text">Runtime</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#what-is-Runtime"><span class="nav-number">2.</span> <span class="nav-text">what is Runtime</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Objective-C相关基础"><span class="nav-number">2.1.</span> <span class="nav-text">Objective-C相关基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#id-amp-Class"><span class="nav-number">2.1.1.</span> <span class="nav-text">id &amp; Class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SEL"><span class="nav-number">2.1.2.</span> <span class="nav-text">SEL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IMP"><span class="nav-number">2.1.3.</span> <span class="nav-text">IMP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method"><span class="nav-number">2.1.4.</span> <span class="nav-text">Method</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ivar"><span class="nav-number">2.1.5.</span> <span class="nav-text">Ivar</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#objc-property-t"><span class="nav-number">2.1.6.</span> <span class="nav-text">objc_property_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cache"><span class="nav-number">2.1.7.</span> <span class="nav-text">Cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Category"><span class="nav-number">2.1.8.</span> <span class="nav-text">Category</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Objective-C的消息传递"><span class="nav-number">2.2.</span> <span class="nav-text">Objective-C的消息传递</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本消息传递"><span class="nav-number">2.2.1.</span> <span class="nav-text">基本消息传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息动态解析"><span class="nav-number">2.2.2.</span> <span class="nav-text">消息动态解析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#———————分割线——————————"><span class="nav-number">3.</span> <span class="nav-text">———————分割线——————————</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#成员变量与属性"><span class="nav-number">3.1.</span> <span class="nav-text">成员变量与属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类型编码"><span class="nav-number">3.1.1.</span> <span class="nav-text">类型编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关联对象"><span class="nav-number">3.1.2.</span> <span class="nav-text">关联对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作方法"><span class="nav-number">3.1.3.</span> <span class="nav-text">操作方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#成员变量"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">成员变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关联对象-1"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">关联对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性"><span class="nav-number">3.1.3.3.</span> <span class="nav-text">属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法与消息"><span class="nav-number">3.2.</span> <span class="nav-text">方法与消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IMP-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">IMP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法相关操作函数"><span class="nav-number">3.2.2.</span> <span class="nav-text">方法相关操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法选择器"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">方法选择器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法调用流程"><span class="nav-number">3.2.3.</span> <span class="nav-text">方法调用流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#隐藏参数"><span class="nav-number">3.2.3.1.</span> <span class="nav-text">隐藏参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取方法地址"><span class="nav-number">3.2.3.2.</span> <span class="nav-text">获取方法地址</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息转发"><span class="nav-number">3.2.4.</span> <span class="nav-text">消息转发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态方法解析"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">动态方法解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#备用接收者"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">备用接收者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#完整消息转发"><span class="nav-number">3.2.4.3.</span> <span class="nav-text">完整消息转发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消息转发与多重继承"><span class="nav-number">3.2.4.4.</span> <span class="nav-text">消息转发与多重继承</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Method-Swizzling"><span class="nav-number">3.3.</span> <span class="nav-text">Method Swizzling</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#swizzling应该总是在-load中执行"><span class="nav-number">3.3.1.</span> <span class="nav-text">swizzling应该总是在+load中执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#swizzling应该总是在dispatch-once中执行"><span class="nav-number">3.3.2.</span> <span class="nav-text">swizzling应该总是在dispatch_once中执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意事项"><span class="nav-number">3.3.3.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协议与分类"><span class="nav-number">3.4.</span> <span class="nav-text">协议与分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Category-1"><span class="nav-number">3.4.1.</span> <span class="nav-text">Category</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Protocol"><span class="nav-number">3.4.2.</span> <span class="nav-text">Protocol</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作函数"><span class="nav-number">3.4.3.</span> <span class="nav-text">操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#category"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">category</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#protocol"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">protocol</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他"><span class="nav-number">3.5.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#super"><span class="nav-number">3.5.1.</span> <span class="nav-text">super</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bokice</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
